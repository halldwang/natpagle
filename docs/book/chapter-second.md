# 简介

到目前为止，我们已经看到了函数式编程的一小部分功能。

但是什么是函数式编程呢？是什么让这一种语言具有这种能力，而不是另一种？是什么让这一种编程风格具有功能，而不是另一种？在本章中，我们将首先回答这些问题，然后介绍函数式编程的核心概念：

- 使用函数和数组控制流
- 编写纯函数、匿名函数、递归函数等
- 像对象一样传递函数
- 使用 map()、filter()和 reduce()函数

## 函数式编程语言

函数式编程是促进函数式编程范例的语言。冒着过度简化的风险，我们可以说，如果一种语言包括函数式编程所需的功能，那么它就是一种函数式语言。在大多数情况下，这是编程风格。

## 是什么让语言具有这样的特性

功能编程不能在像 C 和 Java 语言中执行，因为这些语言不包含支持它的构造方法。它们是纯粹面向对象的非函数式语言。其次，面向对象的编程不能在纯函数式语言上执行（如 Scheme、Haskell 和 Lisp）。但某些语言也支持这两种模型。 Python 是一个著名的例子，但还有其他例子：Ruby，Julia 和我们感兴趣的 JavaScript。 这些语言如何支持两种截然不同的设计模式？ 它们包含两种编程范例所需的功能。 但对于 JavaScript，功能特性值得我们发掘。

但实际上，它涉及的更多。 那么什么使语言具有这样的特性？

|   特性   |            命令            |                     功能性                     |
| :------: | :------------------------: | :--------------------------------------------: |
| 编程风格 | 执行分步任务并管理状态更改 | 定义问题是什么以及实现解决方案需要哪些数据转换 |
| 状态更改 |            重要            |                     不存在                     |
| 执行顺序 |            重要            |                     不重要                     |
| 主程控制 |  循环、条件语句和函数调用  |                 函数调用和递归                 |
| 操纵单元 |        结构和类对象        |           作为一级对象和数据集的函数           |

一种语言的语法必须允许某些设计模式，例如类型推导，以及使用匿名函数的能力。 例如该语言必须实现 λ 演算。 同样，解释器的评估策略应为非严格且按需调用（也称为延迟执行），这允许不可变的数据结构和非严格的惰性计算。

## 优势

可以这样说，学习和理解函数式编程所得的收获：不管你是否成为成为一名全职的函数式程序员，学习的经历都会使你在以后的项目开发中成为一个更好的程序员。

从形式上讲，使用函数式编程的实际优势是什么？

### 代码精简

函数式编程代码更简洁，更小。 简化了调试，测试和维护成本。

例如，假设我们实现一个将二维数组转换为一维数组的函数。 仅使用命令式编程风格，我们这样实现它：

```js
function merge2dArrayIntoOne(arrays) {
  var count = arrays.length;
  var merged = new Array(count);
  var c = 0;
  for (var i = 0; i < count; ++i) {
    for (var j = 0, jlen = arrays[i].length; j < jlen; ++j) {
      merged[c++] = arrays[i][j];
    }
  }
  return merged;
}
```

使用函数式编程技术，可以这样写：

```js
var merge2dArrayIntoOne2 = function(arrays) {
  return arrays.reduce(function(p, n) {
    return p.concat(n);
  });
};
```

这两个函数都使用相同的输入并返回相同的输出。 但是，该下面示例更加简洁明了。

### 模块化

函数式编程的特点将大问题分解为要解决的同一问题的较小实例。 这意味着代码更加模块化。 明确规定了模块化程序，易于调试和维护。同时测试更加容易，因为可以对每个模块化代码进行正确性检查。

### 复用性

由于功能编程的模块化，功能程序共享各种常用的方法。 发现这些功能可以在各种不同的应用程序中重复使用。

后续章节将展示许多最常用的函数功能。作为函数式编程程序员时，不可避免地会开发自己的工具函数库（utils），这些函数可以反复使用。 例如，设计良好的函数方法可以搜索配置文件的各行，也可以用于搜索哈希表。

### 减少耦合

耦合是程序中模块之间的依赖量。由于函数式程序员致力于编写一级、高阶、纯函数，这些函数彼此完全独立，对全局变量没有副作用，因此耦合大大减少。当然，功能之间不可避免地会相互依赖。但修改一个函数不会改变另一个函数，只要输入到输出的一对一映射保持正确。

### 数学上正确

最后一个是从理论上讲的。 由于其起源于 Lambda 微积分，因此可以从数学上证明功能程序是正确的。 对于需要证明程序的增长率，时间复杂度和数学正确性的研究人员来说，这是一个很大的优势。

让我们看一下斐波那契数列。 尽管除了概念证明之外，它很少用于其他任何方面，但它很好地说明了这一概念。 评估斐波那契序列的标准方法是创建一个递归函数，该函数表示:

`fibonnaci（n）= fibonnaci（n-2）+ fibonnaci（n-1`）

并在 n <2 时返回 1，这使得可能 停止递归并开始累加递归调用堆栈中每个步骤返回的值。

以下描述了计算序列所涉及的中间步骤。

```js
var fibonacci = function(n) {
  if (n < 2) {
    return 1;
  } else {
    return fibonacci(n - 2) + fibonacci(n - 1);
  }
};
console.log(fibonacci(8));
// Output: 34
```

但是，借助实现惰性执行策略的库，可以生成不确定的序列，该序列说明定义整个数字序列的数学方程式。 仅计算所需数量的数字。

```js
var fibonacci2 = Lazy.generate(
  (function() {
    var x = 1,
      y = 1;
    return function() {
      var prev = x;
      x = y;
      y += prev;
      return prev;
    };
  })()
);

console.log(fibonacci2.length()); // Output: undefined
console.log(fibonacci2.take(12).toArray()); // Output: [1, 1, 2, 3, 5,8, 13, 21, 34, 55, 89, 144]
var fibonacci3 = Lazy.generate(
  (function() {
    var x = 1,
      y = 1;
    return function() {
      var prev = x;
      x = y;
      y += prev;
      return prev;
    };
  })()
);

console.log(
  fibonacci3
    .take(9)
    .reverse()
    .first(1)
    .toArray()
);
// Output: [34];
```

二个例子显然在数学上更合理。 它依靠惰性计算。 JavaScript 库。 还有其他库也可以在这里提供帮助，例如 Sloth.js 和 wu.js。 这些将在第 3 章，建立函数式编程环境中介绍。

### 非函数世界中的函数式编程

函数式编程和非函数式编程可以混合在一起吗？ 这是第7章JavaScript的功能和面向对象编程的主题，但在此之前，首先要弄清楚一些事情很重要。

本书无意教你如何实现严格遵守纯函数式编程进行项目开发，此类应用很少在学术界以外适用。 这本书将教你如何在应用程序中使用函数式编程设计策略来补充必要的命令性代码。

例如，如果您需要仅包含某些文本中的字母的前四个单词，则可以这样简单地编写它们：

```js
var words = [],
  count = 0;
text = myString.split(" ");
for (i = 0; count < 4, i < text.length; i++) {
  if (!text[i].match(/[0-9]/)) {
    words = words.concat(text[i]);
    count++;
  }
}
console.log(words);
```

相比之下，函数式编程这样写：

```js
var words = [];
var words = myString
  .split(" ")
  .filter(function(x) {
    return !x.match(/[1-9]+/);
  })
  .slice(0, 4);
console.log(words);
```

使用功能性编程实用程序库，可以进一步简化它们：

```js
var words = toSequence(myString).match(/[a-zA-Z]+/).first(4);
```

标识可以以更实用的方式编写的函数的关键是查找循环和临时变量，例如上例中的 words 和 count 实例。

我们可以通过使用高阶函数代替临时变量和循环来消除它们，我们将在本章稍后进行探讨。
