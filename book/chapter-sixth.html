<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>简介 | JavaScript中的函数式编程</title>
    <meta name="description" content="JavaScript 中的函数式编程">
    
    
    <link rel="preload" href="/natpagle/assets/css/0.styles.704ec6d9.css" as="style"><link rel="preload" href="/natpagle/assets/js/app.b21d4d52.js" as="script"><link rel="preload" href="/natpagle/assets/js/2.793adf42.js" as="script"><link rel="preload" href="/natpagle/assets/js/12.f3ea115a.js" as="script"><link rel="prefetch" href="/natpagle/assets/js/10.bb99e574.js"><link rel="prefetch" href="/natpagle/assets/js/11.8cce9fd8.js"><link rel="prefetch" href="/natpagle/assets/js/13.fe574bc4.js"><link rel="prefetch" href="/natpagle/assets/js/14.752b3757.js"><link rel="prefetch" href="/natpagle/assets/js/15.6a578eca.js"><link rel="prefetch" href="/natpagle/assets/js/16.44463992.js"><link rel="prefetch" href="/natpagle/assets/js/3.1f46a39d.js"><link rel="prefetch" href="/natpagle/assets/js/4.832153c4.js"><link rel="prefetch" href="/natpagle/assets/js/5.d5389a0e.js"><link rel="prefetch" href="/natpagle/assets/js/6.4fa878bd.js"><link rel="prefetch" href="/natpagle/assets/js/7.e166f63b.js"><link rel="prefetch" href="/natpagle/assets/js/8.de7b36b8.js"><link rel="prefetch" href="/natpagle/assets/js/9.d3b39cee.js">
    <link rel="stylesheet" href="/natpagle/assets/css/0.styles.704ec6d9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/natpagle/" class="home-link router-link-active"><!----> <span class="site-name">JavaScript中的函数式编程</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/natpagle/" class="nav-link">首页</a></div><div class="nav-item"><a href="/natpagle/book/cover-preface.html" class="nav-link">章节</a></div><div class="nav-item"><a href="/natpagle/book/contribution.html" class="nav-link">贡献内容</a></div> <a href="https://github.com/halldwang/natpagle" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/natpagle/" class="nav-link">首页</a></div><div class="nav-item"><a href="/natpagle/book/cover-preface.html" class="nav-link">章节</a></div><div class="nav-item"><a href="/natpagle/book/contribution.html" class="nav-link">贡献内容</a></div> <a href="https://github.com/halldwang/natpagle" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/natpagle/book/cover-preface.html" class="sidebar-link">章节和目录</a></li><li><a href="/natpagle/book/chapter-first.html" class="sidebar-link">第一章：通过一个案例了解JavaScript语言能力</a></li><li><a href="/natpagle/book/chapter-second.html" class="sidebar-link">第二章：函数式编程基础</a></li><li><a href="/natpagle/book/chapter-third.html" class="sidebar-link">第三章：搭建函数式编程环境</a></li><li><a href="/natpagle/book/chapter-fourth.html" class="sidebar-link">第四章：JavaScript中的函数式编程实现</a></li><li><a href="/natpagle/book/chapter-fifth.html" class="sidebar-link">第五章：理论范畴</a></li><li><a href="/natpagle/book/chapter-sixth.html" class="active sidebar-link">第六章：JavaScript中的高级函数和陷阱话题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#递归" class="sidebar-link">递归</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#y-combinator-推导" class="sidebar-link">Y-Combinator 推导</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#memoization" class="sidebar-link">Memoization</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#变量作用域" class="sidebar-link">变量作用域</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#域范围" class="sidebar-link">域范围</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#全局作用域" class="sidebar-link">全局作用域</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#局部作用域" class="sidebar-link">局部作用域</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#对象属性" class="sidebar-link">对象属性</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#一些问题" class="sidebar-link">一些问题</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#函数声明-vs-函数表达式-vs-函数构造函数" class="sidebar-link">函数声明 vs 函数表达式 vs 函数构造函数</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#函数声明" class="sidebar-link">函数声明</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#function-构造函数" class="sidebar-link">Function()构造函数</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#不可预测的行为" class="sidebar-link">不可预测的行为</a></li><li class="sidebar-sub-header"><a href="/natpagle/book/chapter-sixth.html#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/natpagle/book/chapter-seventh.html" class="sidebar-link">第七章：JavaScript中的函数式和面向对象编程</a></li><li><a href="/natpagle/book/appendix.html" class="sidebar-link">附录：JavaScript中常用函数的函数式方法</a></li><li><a href="/natpagle/book/contribution.html" class="sidebar-link">贡献内容</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h1> <p>JavaScript 被称为“web 的汇编语言”。类比（它不是完美的，还还有更完美的么？），从 JavaScipt 通常被编译的目标（即 Clojure 和 CoffeeScript）这一事实出发，还从许多其他来源（如 pyjamas（python to JS）和 Google Web Kit（Java 到 JS））中得出结论。</p> <p>引用了一个更愚蠢的想法，JavaScript 和 x86 程序集一样具有表现力和低级。也许这个概念源于这样一个事实：自从 JavaScript 在 1995 年首次随 Netscape 一起发布以来，它就一直因其设计缺陷和疏忽而受到抨击。它是在匆忙中开发和发布的，正因为如此，一些有问题的设计模式进入了 JavaScript，这种语言很快成为了事实上的 web 脚本语言。“;”是个大错误。定义函数的方法也不明确。是 var foo = function();还是 function foo();</p> <p>函数式编程是处理这些错误的一个很好的方法。 通过关注 JavaScript 确实是一种函数式语言这一事实，在前面关于声明函数的不同方法的示例中，最好将函数声明为变量。分号主要是为了让 JavaScript 看起来更像 C 语言。</p> <p>但是请始终记住您使用的语言。 与其他任何语言一样，JavaScript 也有其缺陷。 而且，当以一种经常避开可能的前沿优势的风格进行编程时，这些小问题可能会变成不可恢复的问题陷阱。 其中一些陷阱包括：</p> <ul><li>递归</li> <li>可变范围和闭包</li> <li>函数声明与函数表达式</li></ul> <p>不过，这些问题只要稍加注意就可以解决。</p> <h2 id="递归"><a href="#递归" class="header-anchor">#</a> 递归</h2> <p>递归对于任何语言的函数式编程都非常重要。许多函数式语言甚至不提供 for 和 while 循环语句，从而要求迭代递归；只有当语言保证消除尾部调用时，这才是可能的，而 JavaScript 则不是这样。在第 2 章“函数式编程基础”中快速介绍了递归。但在本节中，我们将深入研究递归在 JavaScript 中的工作原理。</p> <h3 id="尾递归"><a href="#尾递归" class="header-anchor">#</a> 尾递归</h3> <p>JavaScript 处理递归的例程称为 tail 递归，这是基于堆栈的递归实现。 这意味着，对于每个递归调用，堆栈中都会有一个新帧。</p> <p>为了说明这个方法可能产生的问题，让我们使用经典的阶乘递归算法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">factorial</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// base case</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// recursive case</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>该算法将调用 n 次以获取答案。 它实际上是在计算（1 x 1 x 2 x 3 x…x N）。 这意味着时间复杂度为 O（n）。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>O(n)，发音为“big oh to the n,&quot;”，意味着随着输入大小的增长，算法将以 n 的速率增长，即较窄的增长。 O(n2)是指数增长，O(log(n))是对数
增长等等。 此符号可用于时间复杂度和空间复杂度。</p></div> <p>但是，因为在每个迭代中分配了存储器堆栈中的新帧，所以空间复杂度也是 O（n）。这是个问题。这意味着内存的消耗速度将很容易超过内存限制。在我的笔记本电脑上，阶乘 factorial(23456)返回<code>Uncaught Error：RangeError: Maximum call stack size exceeded</code>超出最大调用堆栈大小。</p> <p>尽管计算 23,456 的阶乘是一件轻而易举的事，但是可以放心，用递归解决的许多问题将增长到该大小而不会带来太多麻烦。 考虑数据树的情况。 树可以是任何东西：搜索应用程序，文件系统，路由表等等。 下面是树遍历功能的一个非常简单的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">traverse</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// whatever work needs to be done</span>
  node<span class="token punctuation">.</span>childern<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>traverse<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// many recursive calls</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>每个节点只有两个子节点，时间复杂度和空间复杂度（在最坏的情况下，必须遍历整棵树才能找到答案）都将是 O(n2)，因为每个将有两个递归调用。 每个节点有许多子代，复杂度将为 O(nm)，其中 m 是子代数。 递归是树遍历的首选算法； while 循环会复杂得多，并且需要维护堆栈。</p> <p>这样的指数增长意味着不需要很大的 tree 就可以抛出 RangeError 异常。肯定有更好的办法。</p> <h3 id="尾部调用消除"><a href="#尾部调用消除" class="header-anchor">#</a> 尾部调用消除</h3> <p>我们需要一种方法来消除每个递归调用的新堆栈帧的分配。 这被称为尾部调用消除。</p> <p>使用尾部调用消除，当函数返回调用自身的结果时，语言实际上不会执行另一个函数调用。它把整件事都变成了一个循环。</p> <p>好，那我们该怎么做呢？ 有了惰性求值。 如果我们可以重写它来折叠一个延迟序列，这样函数返回一个值，或者它返回调用另一个函数的结果而不对该结果做任何处理，那么就不需要分配新的堆栈帧。</p> <p>要将其放入“尾递归形式”，必须重写阶乘函数，以使内部过程事实在控制流中最后调用自身，如以下代码片段所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">factorial</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token function-variable function">_fact</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// base case</span>
      <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// recursive case</span>
      <span class="token keyword">return</span> <span class="token function">_fact</span><span class="token punctuation">(</span>n <span class="token operator">*</span> x<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>结果不是由递归尾中的第一个函数生成（如在 n <em>factorial(n-1)中），而是由递归尾中的最后一个函数生成（通过调用_fact(r</em> n，n-1) ）），并由该尾部的最后一个函数产生（带有 return r;）。 计算仅向下进行一次，而不向上进行。 将其作为解释器的迭代进行处理相对容易。</p></div> <p>但是，消除尾部调用在 JavaScript 中不起作用。 将上面的代码放入您最喜欢的 JavaScript 引擎中，<code>factorial(24567)</code>仍返回 Uncaught Error：RangeError: Maximum call stack size exceeded exception(最大调用堆栈大小超出异常)。 Tail-call 消除被列为新功能，将包含在下一版 ECMAScript 中，但是所有浏览器都需要一段时间才能实现。</p> <p>语言规范和运行时解释器的功能，简单明了。 它与解释器如何获取堆栈帧资源有关。 某些语言在不需要记住任何新内容时会重用同一堆栈框架，例如前面的函数。 这就是消除 Tail-call 的方法，从而减少了时间和空间的复杂性。</p> <p>不幸的是，JavaScript 无法做到这一点。 但是，如果这样做，它将从此重组堆栈帧：</p> <div class="language-txt extra-class"><pre class="language-text"><code>call factorial (3)
  call fact (3 1)
    call fact (2 3)
      call fact (1 6)
        call fact (0 6)
        return 6
      return 6
    return 6
  return 6
return 6
</code></pre></div><p>具体如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>call <span class="token function">factorial</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
  call <span class="token function">fact</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token number">1</span><span class="token punctuation">)</span>
  call <span class="token function">fact</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span>
  call <span class="token function">fact</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token number">6</span><span class="token punctuation">)</span>
  call <span class="token function">fact</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token number">6</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> <span class="token number">6</span>
<span class="token keyword">return</span> <span class="token number">6</span>
</code></pre></div><h3 id="蹦床函数"><a href="#蹦床函数" class="header-anchor">#</a> 蹦床函数</h3> <p>解决方案？ 一个被称为蹦床的过程。 这是通过使用 thunks 将“尾声消除”概念“破解”到程序中的一种方法。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>因此，Thunk 是带有参数的表达式，这些参数包装了没有自身参数的匿名函数。 例如：<code>function (str){return function() {console.log(str)}</code>。 这样可以防止在接收函数调用匿名函数之前对表达式进行求值。</p></div> <p>蹦床是一个函数，它接受一个函数作为输入，并重复执行其返回值，直到返回函数以外的其他值。下面的代码片段显示了一个简单的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">trampoline</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>f <span class="token operator">&amp;&amp;</span> f <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    f <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>context<span class="token punctuation">,</span> f<span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> f<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>要真正实现 tail-call 消除，我们需要使用 thunks。 为此，我们可以使用 bind()函数，该函数使我们可以将 this 关键字分配给另一个对象的方法应用于一个对象。 在内部，它与 call 关键字相同，但已链接到方法并返回一个新的绑定函数。 bind()函数实际上执行部分应用程序，但实际上确实可以部分应用。</p> <p>要真正实现尾部调用消除，我们需要使用 thunks。为此，我们可以使用 bind（）函数，该函数允许我们将一个方法应用于一个对象，并将此关键字分配给另一个对象。在内部，它与 call 关键字相同，但它链接到方法并返回一个新的绑定函数。bind（）函数实际上执行部分应用程序，尽管方式非常有限。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">factorial</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token function-variable function">_fact</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// base case</span>
      <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// recursive case</span>
      <span class="token keyword">return</span> <span class="token function">_fact</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> n <span class="token operator">*</span> x<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">trampoline</span><span class="token punctuation">(</span><span class="token function">_fact</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>但是，编写 fact.bind(null，...)方法很麻烦，并且会使代码阅读困难。 取而代之的是，让我们编写自己的函数来创建 thunk()， 函数做以下几件事：</p> <ul><li>thunk()函数必须模拟_fact.bind(null，n * x，n-1)方法返回一个未求值的函数</li> <li>thunk()函数应包含另外两个函数：
<ul><li>用于处理给定函数，以及</li> <li>用于处理调用给定函数时将使用的函数参数</li></ul></li></ul> <p>这样，我们就可以编写函数了。我们只需要几行代码就可以编写它。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">thunk</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>现在我们可以在阶乘算法中使用 thunk()函数，如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">factorial</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token function-variable function">fact</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">thunk</span><span class="token punctuation">(</span>fact<span class="token punctuation">)</span><span class="token punctuation">(</span>n <span class="token operator">*</span> x<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">trampoline</span><span class="token punctuation">(</span><span class="token function">thunk</span><span class="token punctuation">(</span>fact<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>另外，我们可以通过将_fact()函数定义为 thunk()函数来进一步简化它。通过将内部函数定义为 thunk()函数，我们就不用在内部函数定义和 return 语句中都使用 thunk()函数了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">factorial</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> _fact <span class="token operator">=</span> <span class="token function">thunk</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// base case</span>
      <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// recursive case</span>
      <span class="token keyword">return</span> <span class="token function">_fact</span><span class="token punctuation">(</span>n <span class="token operator">*</span> x<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">trampoline</span><span class="token punctuation">(</span><span class="token function">_fact</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>结果令人满意。 对于无尾递归，递归调用的函数_fact()几乎透明地作为迭代处理</p> <p>最后，让我们看看 trampoline()和 thunk()函数如何与我们更有意义的树遍历示例一起工作。下面案例说明如何使用 trampolining 和 thunk 来遍历数据树：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">treeTraverse</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">trunk</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> _traverse <span class="token operator">=</span> <span class="token function">thunk</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>_traverse<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">trampoline</span><span class="token punctuation">(</span><span class="token function">_traverse</span><span class="token punctuation">(</span>trunk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们已经解决了尾部递归的问题。但还有更好的办法吗？如果我们可以简单地将递归函数转换为非递归函数呢？下一节，我们看看如何做。</p> <h2 id="y-combinator-推导"><a href="#y-combinator-推导" class="header-anchor">#</a> Y-Combinator 推导</h2> <p>在计算机科学中，Y-combinator 推导甚至让编程大师们感到震惊。它将递归函数自动转换为非递归函数的能力，这就是为什么 Douglas Crockford 将其称为“计算机科学中最奇怪、最奇妙的产物之一”的原因，而 Sussman 和 Steele 曾经说过，“这种方法真的很了不起”。</p> <p>264/5000
因此，将递归功能带到膝盖的计算机科学的真正卓越，奇特的奇特产物必须庞大而复杂，对吗？ 不，不完全是。 它在 JavaScript 中的实现只有九行，非常奇怪。 它们如下：</p> <p>它在 JavaScript 中的实现只有九行的代码。具体如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">Y</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">F</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>它的工作原理如下：它找到作为参数传入的函数的“固定点”。定点提供了另一种考虑功能的方法，而不是计算机编程理论中的递归和迭代。它仅通过使用匿名函数表达式，函数应用程序和变量引用来完成此操作。这里注意，Y 并没有引用它自己。实际上，所有这些都是匿名函数。（<a href="https://www.zhihu.com/question/20115649" target="_blank" rel="noopener noreferrer">知乎：函数式编程的 Y Combinator 有哪些实用价值？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p> <p>正如你可能已经猜到的，Y-combinator 来自 lambda 表达式。它实际上是在另一个叫做 U-combinator 的组合器的帮助下导出的。组合器是一种特殊的高阶函数，它只使用函数应用程序和早期定义的组合器来定义输入的结果。</p> <p>为了演示 Y-combinator，我们将再次讨论阶乘问题，但是我们需要对阶乘函数的定义稍有不同。我们编写的函数不是递归函数，该函数是阶乘的数学定义。 然后，我们可以将其传递给 Y-combinator。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">FactorialGen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">factorial</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// base case</span>
      <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// recursive case</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n – <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Factorial <span class="token operator">=</span> <span class="token constant">Y</span><span class="token punctuation">(</span>FactorialGen<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Factorial</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3628800</span>
</code></pre></div><p>但是，当我们给它一个很大的数字时，堆栈会溢出，就像使用了没有 trampolining 函数（蹦床函数）的尾递归一样。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">Factorial</span><span class="token punctuation">(</span><span class="token number">23456</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// RangeError: Maximum call stack size exceeded</span>
</code></pre></div><p>但是我们可以将 Y-combinator 用于蹦床函数，如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">FactorialGen2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">factorial</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> factorial <span class="token operator">=</span> <span class="token function">thunk</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">*</span> x<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">trampoline</span><span class="token punctuation">(</span><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> Factorial2 <span class="token operator">=</span> <span class="token constant">Y</span><span class="token punctuation">(</span>FactorialGen2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Factorial2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3628800</span>
<span class="token function">Factorial2</span><span class="token punctuation">(</span><span class="token number">23456</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Infinity</span>
</code></pre></div><p>我们还可以重新排列 Y-combinator 来执行一种叫做 Memoization 的操作。</p> <h2 id="memoization"><a href="#memoization" class="header-anchor">#</a> Memoization</h2> <p>Memoization 是 JavaScript 中的一种技术，通过缓存结果并在下一个操作中重新使用缓存来加速查找费时的操作。</p> <p>尽管 Y 组合器比递归快得多，但它仍然相对较慢。 为了加快速度，我们可以创建一个记忆定点组合器：类似 Y 的组合器，用于缓存中间函数调用的结果。</p> <p>尽管 Y-combinator 运算比递归运算快得多，但它仍然相对较慢。为了加快速度，我们可以创建一个 Memoization 优化组合：一个类似 Y-combinator 组合器，用于缓存中间函数调用的结果。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">Ymem</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">F</span><span class="token punctuation">,</span> cache</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Create a new cache.</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">[</span>arg<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// Answer in cache</span>
      <span class="token keyword">return</span> cache<span class="token punctuation">[</span>arg<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// else compute the answer</span>
    <span class="token keyword">var</span> answer <span class="token operator">=</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">Ymem</span><span class="token punctuation">(</span><span class="token constant">F</span><span class="token punctuation">,</span> cache<span class="token punctuation">)</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Compute the answer.</span>
    cache<span class="token punctuation">[</span>arg<span class="token punctuation">]</span> <span class="token operator">=</span> answer<span class="token punctuation">;</span> <span class="token comment">// Cache the answer.</span>
    <span class="token keyword">return</span> answer<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>那么要快多少呢？通过使用<a href="http://jsperf.com/" target="_blank" rel="noopener noreferrer">http://jsperf.com/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，我们可以比较性能。</p> <p>以下结果是 1 到 100 之间的随机数。我们可以看到，记忆的（memoizing） Y-combinator 快得多。 并且向其添加蹦床函数不会使它减慢太多。 您可以在以下 URL 上查看结果并自己运行测试：<a href="http://jsperf.com/memoizing-y-combinator-vs-tail-calloptimization/7" target="_blank" rel="noopener noreferrer">http://jsperf.com/memoizing-y-combinator-vs-tail-calloptimization/7<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p><img src="https://blog.ahthw.com/wp-content/uploads/2019/12/y-combinator.png" alt="img"></p> <p>底线是：在 JavaScript 中执行递归的最安全有效的方法是通过蹦床函数和 thunk 来使用带有 Tail-call 消除的 memoization Y-combinator 组合器。</p> <h2 id="变量作用域"><a href="#变量作用域" class="header-anchor">#</a> 变量作用域</h2> <p>JavaScript 中变量作用域不是既定的，有人说 JavaScript 程序员可以通过对代码的理解程度来判断其作用域。</p> <h2 id="域范围"><a href="#域范围" class="header-anchor">#</a> 域范围</h2> <p>让我们讨论一下 JavaScript 中的不同域解析，JavaScript 使用作用域链来建立变量的作用域。 解析变量时，它从最内部的域开始并向外搜寻。</p> <h2 id="全局作用域"><a href="#全局作用域" class="header-anchor">#</a> 全局作用域</h2> <p>在此级别定义的变量，函数和对象可用于整个程序中的任何代码。 这是最外部的作用域。</p> <h2 id="局部作用域"><a href="#局部作用域" class="header-anchor">#</a> 局部作用域</h2> <p>每个函数都有自己的局部作用域。在另一个函数中定义的任何函数都具有链接到外部函数的嵌套局部作用域，几乎总是由源中的位置定义范围。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">&quot;hi&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hi</span>
</code></pre></div><p>局部作用域仅适用于函数，不适用于任何表达式语句（if, for, while 等），这与大多数语言对待作用域的方式不同。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token string">&quot;greetings&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token string">&quot;guten tag&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token string">&quot;greetings&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token string">&quot;guten tag&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'guten tag'</span>
<span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'greetings'</span>
</code></pre></div><p>在函数式编程中，这并不是什么大问题，因为函数的使用频率更高，而表达式语句的使用频率更低。 例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> z <span class="token operator">=</span> <span class="token string">'namaste'</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">foreach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> z <span class="token operator">=</span> <span class="token string">'aloha'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">isTrue</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> z <span class="token operator">=</span> <span class="token string">'good morning'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">e</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'namaste'</span>
</code></pre></div><h2 id="对象属性"><a href="#对象属性" class="header-anchor">#</a> 对象属性</h2> <p>对象属性也有自己的作用域链。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">&quot;hi&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">obj</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token string">&quot;hola&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'hola'</span>
foo<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token string">&quot;bonjour&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'bonjour'</span>
</code></pre></div><p>并且对象的原型在作用域链的下游。</p> <div class="language-js extra-class"><pre class="language-js"><code>obj<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token string">&quot;greetings&quot;</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token string">&quot;konnichi ha&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// still prints 'hola'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'konnichi ha'</span>
</code></pre></div><h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <p>这种作用域结构的一个问题是它没有空间容纳私有变量。如以下代码段：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;Ford Focus&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> year <span class="token operator">=</span> <span class="token string">&quot;2006&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> millage <span class="token operator">=</span> <span class="token number">123456</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">getMillage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> millage<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">updateMillage</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  millage <span class="token operator">=</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这些变量和函数是全局的，这意味着后面的代码很容易意外覆盖它们。 一种解决方案是将它们封装到一个函数中，并在定义它后立即调用该函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> car <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;Ford Focus&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> year <span class="token operator">=</span> <span class="token string">&quot;2006&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> millage <span class="token operator">=</span> <span class="token number">123456</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">getMillage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Millage<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">updateMillage</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    millage <span class="token operator">=</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>函数之外什么都没有发生，因此我们应该通过使匿名函数来丢弃它。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;Ford Focus&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> year <span class="token operator">=</span> <span class="token string">&quot;2006&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> millage <span class="token operator">=</span> <span class="token number">123456</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">getMillage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> millage<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">updateMillage</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    millage <span class="token operator">=</span> n<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>为了使函数 getValue()和 updateMillage()在匿名函数之外可用，我们需要以对象文本形式返回它们，如以下代码片段所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> car <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;Ford Focus&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> year <span class="token operator">=</span> <span class="token string">&quot;2006&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> millage <span class="token operator">=</span> <span class="token number">123456</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">getMillage</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> millage<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">updateMillage</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      millage <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>car<span class="token punctuation">.</span><span class="token function">getMillage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// works</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>car<span class="token punctuation">.</span><span class="token function">updateMillage</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// also works</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>car<span class="token punctuation">.</span>millage<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre></div><p>以上方法我们为我们提供了伪私有变量，但问题并不止于此。下一节将探讨 JavaScript 中变量作用域的更多问题。</p> <h2 id="一些问题"><a href="#一些问题" class="header-anchor">#</a> 一些问题</h2> <p>在 JavaScript 中可以找到许多可变范围的细微差别。以下并非一份全面的清单，但涵盖了最常见的情况：</p> <ul><li>以下将输出 4，而不是预期的'undefined'：<code>for (var n = 4; false; ) { } console.log(n);</code>这是因为在 JavaScript 中，变量定义发生在相应作用域的开头，而不仅仅是在声明时。</li> <li>如果在外部作用域中定义了一个变量，然后让 If 语句在函数内部使用相同的名称定义一个变量，即使没有到达分支，也会重新定义它。例如：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Return value: 'undefined', expected return value:2;</span>
<span class="token comment">// 同样，这是由于将变量定义移至未定义值的范围的开头而引起的。</span>
</code></pre></div><ul><li>在浏览器中，全局变量实际上存储在 window 对象中。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">19</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Output: 19</span>
</code></pre></div><p>全局范围内的 a 表示 a 作为当前上下文的属性，因此 a === this.a 和浏览器中的 window 对象等效于全局范围内 this 关键字。</p> <p>前两个示例是 JavaScript 功能（称为提升）的结果，这将成为下一部分有关编写函数的关键概念。</p> <h2 id="函数声明-vs-函数表达式-vs-函数构造函数"><a href="#函数声明-vs-函数表达式-vs-函数构造函数" class="header-anchor">#</a> 函数声明 vs 函数表达式 vs 函数构造函数</h2> <p>这三个语句有什么区别？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&quot;n&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;return n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>乍一看，它们只是编写同一函数的不同方式。 但是这里还有更多事情要做。 而且，如果我们要充分利用 JavaScript 中的功能，以便将其操纵为功能编程风格，那么我们最好能够做到这一点。 如果有更好的方法可以在计算机编程中做某事，那么该方法应该是唯一的方法。</p> <h2 id="函数声明"><a href="#函数声明" class="header-anchor">#</a> 函数声明</h2> <p>函数声明（有时也称为函数语句）通过使用 function 关键字定义函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用此语法声明的函数将提升到当前作用域的顶部。 这实际上意味着的是，即使将函数定义了几行，JavaScript 也会知道它，并且可以在范围内更早地使用它。 例如，以下将方法正确打印数字 6：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> m</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n <span class="token operator">*</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="函数表达式"><a href="#函数表达式" class="header-anchor">#</a> 函数表达式</h3> <p>通过定义匿名函数并将其分配给变量，命名函数也可以定义为表达式。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> m</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n <span class="token operator">*</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>它们不像函数声明那样被提升。这是因为，在提升函数声明时，变量声明不会。例如，这将不起作用并引发错误：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> m</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n <span class="token operator">*</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在函数式编程中，我们将要使用函数表达式，以便将函数视为变量，使它们可用作回调和高阶函数（例如 map()函数）的参数。 将函数定义为表达式使它们更明显地成为分配给函数的变量。 另外，如果我们要以一种分格编写函数，为了一致性和清晰性，我们应该用这种样式编写所有函数。</p> <h2 id="function-构造函数"><a href="#function-构造函数" class="header-anchor">#</a> Function()构造函数</h2> <p>JavaScript 实际上还有第三种创建函数的方法：使用 Function()构造函数。 就像函数表达式一样，不会悬挂使用 Function()构造函数定义的函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> func <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&quot;n&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;m&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;return n+m&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">func</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 5</span>
</code></pre></div><p>但是 Function()构造函数不仅令人困惑，而且非常危险。 无法进行语法校正，无法进行优化。 编写相同的函数，如下所示更加容易，安全和避免混淆：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> m</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> n <span class="token operator">+</span> m<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">func</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 5</span>
</code></pre></div><h2 id="不可预测的行为"><a href="#不可预测的行为" class="header-anchor">#</a> 不可预测的行为</h2> <p>所以不同的是，函数声明是提升的，而函数表达式不是。这会导致意想不到的事情发生。请考虑以下几点：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">&quot;hi&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实际打印到控制台的是hello。这是因为foo()函数的第二个定义被提升到了顶部，成为JavaScript解释器实际使用的声明。</p> <p>乍一看，这似乎并不是关键的区别，但在函数式编程中，这可能会造成混乱。 考虑以下代码片段：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;one&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;two&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当调用foo()函数时，two被打印到控制台，而不是one！</p> <p>最后，还有一种方法可以将函数表达式和声明结合起来：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'hi'</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: bar is not defined</span>
</code></pre></div><p>这种方式的使用方法没有什么意义，因为声明中使用的名称（前例中的bar()函数）在函数外部不可用，并导致混淆。它只适用于递归，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>JavaScript被称为“web的汇编语言”，因为它和x86汇编一样无处不在，不可避免。它是所有浏览器上唯一运行的语言。它也有缺陷，但把它作为一种低级语言来指是没有意义的。</p> <p>相反，可以将JavaScript看作是web的原始咖啡豆。当然，有些豆子坏了，有些烂了。但是，如果好的咖啡豆是由一位熟练的咖啡师挑选、烘焙和酿造的，那么这些咖啡豆就可以变成一种绝妙的果酱，而这种果酱不可能只吃一次就被遗忘。它的消费成为一种日常习惯，没有它的生活将是静止的，更难回顾，更不令人兴奋。有些人甚至更喜欢使用插件和诸如奶油、糖和可可之类的附加组件来增强啤酒的质量，这些插件和附加组件可以很好地补充啤酒的质量。</p> <p>引用JavaScript的最大批评家之一Douglas Crawford说：“肯定有很多人拒绝考虑JavaScript有没有可能做对任何事情。我以前也是那种人。但现在我仍然对那里的辉煌感到惊讶。</p> <p>JavaScript真是太棒了。</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/halldwang/natpagle/edit/master/docs/book/chapter-sixth.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">12/31/2019, 10:38:28 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/natpagle/book/chapter-fifth.html" class="prev">第五章：理论范畴</a></span> <span class="next"><a href="/natpagle/book/chapter-seventh.html">第七章：JavaScript中的函数式和面向对象编程</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/natpagle/assets/js/app.b21d4d52.js" defer></script><script src="/natpagle/assets/js/2.793adf42.js" defer></script><script src="/natpagle/assets/js/12.f3ea115a.js" defer></script>
    <script type="text/javascript">
     var _mtac = {};
     (function() {
       var mta = document.createElement("script");
       mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
       mta.setAttribute("name", "MTAH5");
       mta.setAttribute("sid", "500706003");
       var s = document.getElementsByTagName("script")[0];
       s.parentNode.insertBefore(mta, s);
     })();
    </script>
  </body>
</html>
